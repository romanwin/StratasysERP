CREATE OR REPLACE PACKAGE BODY APPS.xxqa_nc_rpt_pkg
AS
  -----------------------------------------------------------------------
  --  name:               xxqa_nc_rpt_pkg
  --  create by:          xxxxxxxx
  --  Revision:           1.0
  --  creation date:      xxxxxxx
  --  Purpose :           CHG0040770 - Quality Nonconformance Report
  ----------------------------------------------------------------------------------
  --  ver   date          name            desc
  --  1.0   xxxxxx        xxxxx           S3 Initial Build
  --  1.1   12-June-2017  Lingaraj(TCS)   CHG0040770  - Quality Nonconformance Report
  -----------------------------------------------------------------------------------


  -----------------------------------------------------------------------
  --  name:               collection_plan_view_name
  --  create by:          xxxxxxxx
  --  Revision:           1.0
  --  creation date:      xxxxxxx
  --  Purpose :           CHG0040770 - Quality Nonconformance Report
  ----------------------------------------------------------------------------------
  --  ver   date          name            desc
  --  1.0   xxxxxx        xxxxx           S3 Initial Build
  --  1.1   12-June-2017  Lingaraj(TCS)   CHG0040770  - Quality Nonconformance Report
  -----------------------------------------------------------------------------------
   FUNCTION collection_plan_view_name (
     p_plan_type IN VARCHAR2
     , p_organization_id IN NUMBER
   ) RETURN VARCHAR2;  

  PROCEDURE write_message(p_msg         VARCHAR2,
                          p_destination VARCHAR2 DEFAULT fnd_file.log) IS
  BEGIN
    IF fnd_global.conc_request_id = '-1' THEN
      dbms_output.put_line(p_msg);
    ELSE
      fnd_file.put_line(p_destination,
                        p_msg);
    END IF;
  END write_message;

   --*****************************************************************************
   --*  PUBLIC FUNCTIONS
   --*****************************************************************************

  -----------------------------------------------------------------------
  --  name:               f_report_data
  --  create by:          xxxxxxxx
  --  Revision:           1.0
  --  creation date:      xxxxxxx
  --  Purpose :           CHG0040770 - Quality Nonconformance Report
  ----------------------------------------------------------------------------------
  --  ver   date          name            desc
  --  1.0   xxxxxx        xxxxx           S3 Initial Build
  --  1.1   12-June-2017  Lingaraj(TCS)   CHG0040770  - Quality Nonconformance Report
  -----------------------------------------------------------------------------------
   FUNCTION f_report_data (
                            p_sequence_1_value IN VARCHAR2
                           ,p_sequence_2_value IN VARCHAR2
                           ,p_sequence_3_value IN VARCHAR2
                           ,p_organization_id  IN NUMBER)
   RETURN apps.XXQA_NC_RPT_TAB_TYPE
    --* Description:
    --*    This function return rows for the data required in the Quality
    --*    Nonconformance Report.
    --*    This package is required due to the dynamic way in which Oracle Quality
    --*    stores results in qa_results.  There is no guarantee that a given
    --*    collection element will be mapped to a specific column (CHARACTER1
    --*    through CHARACTER100) in qa_results.  To work around this, we use the
    --*    collection plan-specific result views that are generated by Oracle EBS.
    --*    These result views abstract the underlying columns in qa_results by
    --*    providing column names that are the same as the Collection Element name.
    --*    Using these views solves the element-to-column mapping issue with
    --*    qa_results.  However, each collection plan has its own unique results
    --*    view, such that a "Nonconformance" collection plan in one org will have a
    --*    different view than a nonconformance collection plan in another org.  To
    --*    make sure that the correct view is used, we use dynamic SQL, with the
    --*    Organization Code and Collection Play Type being the key variables in
    --*    this SQL.  This allows us to have a "global" report rather than org
    --*    -specific reports.
    --* Inputs:
    --*    p_sequence_1_value: Nonconformance Number (optional)
    --*    p_sequence_2_value: Verify Nonconformance Number (optional)
    --*    p_sequence_3_value: Disposition Number (optional)
    --*    p_organization_id: Organization ID for which the quality nonconformance
    --*    was entered.  (required)
    --* Outputs:
    --*    APPS.XXQA_NC_RPT_TAB_TYPE: contains one row for each branch
    --*    (combination) in the quality result parent-child hierarchy for:
    --*    Nonconformance Number>Verify Nonconformance Number>Disposition Number.
    --*    While p_sequence_1_value is required, p_sequence_2_value and
    --*    p_sequence_3_value are optional.  When either of the later two are
    --*    specified, this limits the rows to just that specific Verify
    --*    Nonconformance Number and/or Disposition Number.
   IS
        /* Local Constants*/
        c_where_clause_seq_1 VARCHAR2 (150) := Q'[ AND n_nonconformance_number = ]';  --Base WHERE clause, pertaining to the Nonconformacne Number for the dynamic SQL statement.
        c_where_clause_seq_2 VARCHAR2 (150) := Q'[ AND v_verify_nc_number = ]';  --Base WHERE clause, pertaining to the Verify Nonconformance Number for the dynamic SQL statement.
        c_where_clause_seq_3 VARCHAR2 (150) := Q'[ AND d_disposition_number = ]';  --Base WHERE clause, pertaining to the Disposition Number for the dynamic SQL statement.
        c_where_clause_org_id VARCHAR2(150) := Q'[ AND n_organization_id = ]';  --Base WHERE clause, pertaining to the Organization ID for the dynamic SQL statement.

        /* Local Variables */
        /* View Names */
        l_view_name_1 VARCHAR2(50); --View name for org-specific Nonconformance collection plan
        l_view_name_2 VARCHAR2(50); --View name for org-specific Verify Nonconformance collection plan
        l_view_name_3 VARCHAR2(50); --View name for org-specific Disposition collection plan

        /* Local copy of function parameter values*/
        l_sequence_number_1 VARCHAR2 (150);  --Nonconformance Number
        l_sequence_number_2 VARCHAR2 (150);  --Verify Nonconformance Number
        l_sequence_number_3 VARCHAR2 (150);  --Disposition Number
        l_organization_id NUMBER;

        l_result_temp APPS.XXQA_NC_RPT_TAB_TYPE := APPS.XXQA_NC_RPT_TAB_TYPE();  -- Holds the result of the dynamic sql query

        /* Local variables for dynamic SQL */
        l_dynamic_sql VARCHAR2(32000);  --Holds dynamic SQL statement
        l_where_clause_seq_1 VARCHAR2 (150);  --Component of WHERE clause, pertaining to the Nonconformacne Number for the dynamic SQL statement.
        l_where_clause_seq_2 VARCHAR2 (150);  --Component of WHERE clause, pertaining to the Verify Nonconformance Number for the dynamic SQL statement.
        l_where_clause_seq_3 VARCHAR2 (150);  --Component of WHERE clause, pertaining to the Disposition Number for the dynamic SQL statement.
        l_where_clause_org_id VARCHAR2 (150);  --Component of WHERE clause, pertaining to the Organization ID for the dynamic SQL statement.

        /* Cursors*/
        TYPE t_ref_cursor IS REF CURSOR;-- (REF CURSOR is the same thing as SYS_REFCURSOR)
        cur_dynamic t_ref_cursor;

    BEGIN
        IF c_debug_level = 10 THEN
            write_message(c_output_header);
        END IF;

        /* Prepare Parameters*/
        l_sequence_number_1 := dbms_assert.enquote_literal(str => p_sequence_1_value);--Add single quotes
        l_sequence_number_2 := dbms_assert.enquote_literal(str => p_sequence_2_value);--Add single quotes
        l_sequence_number_3 := dbms_assert.enquote_literal(str => p_sequence_3_value);--Add single quotes
        l_organization_id   := p_organization_id;

        /* Build components of the WHERE clause.
        Note: In the event that a null is passed for a given sequence parameter,
        we will not include that parameter in the WHERE clause, to provide flexibility for the calling
        procedure or concurrent program.  The user can thus be as specific as they like when running the
        Quality Nonconformance Report. However, in practice on the front end, we will make the Nonconformance Number a required
        parameter so that they don't inadvertently run the report "wide open".  Allowing this to be run wide open may
        be beneficial in case we need to do some analytical reporting in Oracle EBS or Oracle BI.
        */
        CASE WHEN p_sequence_1_value IS NOT NULL THEN
            l_where_clause_seq_1 := c_where_clause_seq_1 || l_sequence_number_1;
        ELSE
            l_where_clause_seq_1 := NULL;
        END CASE;

        CASE WHEN p_sequence_2_value IS NOT NULL THEN
            l_where_clause_seq_2 := c_where_clause_seq_2 || l_sequence_number_2;
        ELSE
            l_where_clause_seq_2 := NULL;
        END CASE;

        CASE WHEN p_sequence_3_value IS NOT NULL THEN
            l_where_clause_seq_3 := c_where_clause_seq_3 || l_sequence_number_3;
        ELSE
            l_where_clause_seq_3 := NULL;
        END CASE;

        l_where_clause_org_id := c_where_clause_org_id || l_organization_id;

        IF c_debug_level = 10 THEN
            write_message('WHERE clause components built.');
        END IF;

        /* Get the view names that will be used in the dynamic SQL*/
        l_view_name_1 := collection_plan_view_name(p_plan_type => c_plan_type_code_1, p_organization_id => l_organization_id); --View name for org-specific Nonconformance collection plan
        l_view_name_2 := collection_plan_view_name(p_plan_type => c_plan_type_code_2, p_organization_id => l_organization_id); --View name for org-specific Verify Nonconformance collection plan
        l_view_name_3 := collection_plan_view_name(p_plan_type => c_plan_type_code_3, p_organization_id => l_organization_id); --View name for org-specific Disposition collection plan

        IF c_debug_level = 10 THEN
            --fnd_file.put_line( fnd_file.log, 'Names of views determined:' || l_view_name_1 || ', ' || l_view_name_2 || ', ' || l_view_name_3);
            --dbms_output.put_line('Names of views determined: ' || l_view_name_1 || ', ' || l_view_name_2 || ', ' || l_view_name_3);
            write_message('Names of views determined: ' || l_view_name_1 || ', ' || l_view_name_2 || ', ' || l_view_name_3);
        END IF;

        /* Verify that each view name is valid, in part to reduce risk of SQL injection.
           Oracle will raise the exception, ORA-44002: invalid object name, if one
           of these views do not exist.
        */
        l_view_name_1 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_1);
        l_view_name_2 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_2);
        l_view_name_3 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_3);

        IF c_debug_level = 10 THEN
            --fnd_file.put_line( fnd_file.log, 'Existence of views confirmed.' );
            --dbms_output.put_line('Existence of views confirmed.');
            write_message('Existence of views confirmed.');
        END IF;

        IF c_debug_level = 10 THEN
            --fnd_file.put_line( fnd_file.log, 'Begin build of dynamic SQL.' );
            --dbms_output.put_line('Begin build of dynamic SQL.');
            write_message('Begin build of dynamic SQL.');
        END IF;

    /* Build a dynamic SQL Statement.  Note the use of the alternative quoting
       mechanism (Q') using "[" as the quote_delimiter.  This is to make the
       use of single quotes in the variable clearer. Note that bind variables
       are not, and cannot, be used because the view/table names will be
       different across orgs. (Bind variables can't be used to specify table or
       view names.)
    */
    l_dynamic_sql := Q'[
    /* This SQL returns all of the information required for the Quality
    Nonconformance Report.  This is affixed to nonconforming material as it
    progresses through an inspection and eventually disposiiton.  The report
    provides information at each of these three levels.  Therefore, it can be
    reprinted as information is entered/updated in each collection plan
    so that the report affixed to the nonconforming material is as up-to-date
    as possible.*/

    WITH sq_n
        /* Subquery for nonconformance-level data.*/
    AS (
        SELECT qnv.*
        ,ROW_NUMBER() OVER (PARTITION BY qnv.xx_nonconformance_number
        ORDER BY qnv.xx_nonconformance_number) nonconformance_row
        FROM  ]' || l_view_name_1 || Q'[ qnv
        )
        ,sq_v
        /* Subquery for verify nonconformance-level data.*/
    AS (
        SELECT qiv.*
        ,ROW_NUMBER() OVER (PARTITION BY qiv.xx_nonconformance_no_reference
        ORDER BY qiv.xx_verify_nc_number) verify_nc_row
        ,count(qiv.xx_verify_nc_number) OVER (PARTITION BY qiv.xx_nonconformance_no_reference) verify_nc_row_count
        FROM ]' || l_view_name_2 || Q'[ qiv
        )
        ,sq_d
        /* Subquery for disposition-level data.*/
    AS (
        SELECT qdv.*
        ,ROW_NUMBER() OVER (PARTITION BY qdv.xx_nonconformance_no_reference
        ORDER BY qdv.xx_disposition_number) disposition_row
        ,count(qdv.xx_disposition_number) OVER (PARTITION BY qdv.xx_nonconformance_no_reference) disposition_row_count
        FROM ]' || l_view_name_3 || Q'[ qdv
        )
        ,sq_pcrr
        /* Subquery for parent-child results relationship. */
    AS (
        SELECT parent_plan_id
            ,parent_occurrence
            ,child_plan_id
            ,child_occurrence
        FROM qa_pc_results_relationship_v
        )
        ,sq_nid
        /* Join results of Nonconformance, Verify Nonconformances, and Dispositions. */
    AS (
        SELECT
	    sq_n.nonconformance_row n_nonconformance_row
	    ,sq_n.plan_id n_plan_id
		,sq_n.plan_name n_plan_name
		,sq_n.organization_id n_organization_id
		,sq_n.organization_name n_organization_name
		,sq_n.collection_id n_collection_id
		,sq_n.occurrence n_occurrence
		,sq_n.last_update_date n_last_update_date
		,sq_n.last_updated_by_id n_last_updated_by_id
		,sq_n.last_updated_by n_last_updated_by
		,sq_n.creation_date n_creation_date
		,sq_n.created_by_id n_created_by_id
		,sq_n.created_by n_created_by
		,sq_n.last_update_login n_last_update_login
		--,sq_n.transaction_number n_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
		,sq_n.xx_nonconformance_number n_nonconformance_number
		,sq_n.xx_inspector_name n_inspector_name
		,sq_n.xx_event_date n_event_date
		,sq_n.wip_entity_id n_wip_entity_id
		,sq_n.job n_job
		,sq_n.item_id n_item_id
		,sq_n.item n_item
		,sq_n.xx_item_description n_item_description
		,sq_n.quantity n_quantity
		,sq_n.uom_name n_uom_name
		,sq_n.serial_number n_serial_number
		,sq_n.xx_failure_location_general n_failure_location_general
		,sq_n.xx_failure_location_detail n_failure_location_detail
		,sq_n.xx_nonconformance_symptom n_nonconformance_symptom
		,sq_n.xx_comments_long n_comments_long
		,sq_n.xx_rcv_inspection_no_reference n_rcv_inspection_no_reference
		,sq_n.xx_wip_inspection_no_reference n_wip_inspection_no_reference
		,sq_n.vendor_id n_vendor_id
		,sq_n.supplier n_supplier
		,sq_n.supplier_site n_supplier_site
		,sq_n.po_header_id n_po_header_id
		,sq_n.po_number n_po_number
		,sq_n.po_line_number n_po_line_number
		,sq_n.xx_nonconformance_status n_nonconformance_status
		,sq_n.xx_organization_code n_organization_code
		,sq_n.xx_collection_plan_name n_collection_plan_name
		,sq_n.xx_database_name n_database_name
		,pcrr1.parent_plan_id v_parent_plan_id
		,pcrr1.parent_occurrence v_parent_occurrence
		,pcrr1.child_plan_id v_child_plan_id
		,pcrr1.child_occurrence v_child_occurrence
		,sq_v.verify_nc_row v_verify_nc_row
		,sq_v.verify_nc_row_count v_verify_nc_row_count
		,sq_v.plan_id v_plan_id
		,sq_v.plan_name v_plan_name
		,sq_v.organization_id v_organization_id
		,sq_v.organization_name v_organization_name
		,sq_v.collection_id v_collection_id
		,sq_v.occurrence v_occurrence
		,sq_v.last_update_date v_last_update_date
		,sq_v.last_updated_by_id v_last_updated_by_id
		,sq_v.last_updated_by v_last_updated_by
		,sq_v.creation_date v_creation_date
		,sq_v.created_by_id v_created_by_id
		,sq_v.created_by v_created_by
		,sq_v.last_update_login v_last_update_login
		--,sq_v.transaction_number v_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
		,sq_v.xx_verify_nc_number v_verify_nc_number
		,sq_v.xx_inspector_name v_inspector_name
		,sq_v.xx_event_date v_event_date
		,sq_v.xx_nonconformance_no_reference v_nonconformance_no_reference
		,sq_v.xx_rcv_inspection_no_reference v_rcv_inspection_no_reference
		,sq_v.xx_wip_inspection_no_reference v_wip_inspection_no_reference
		,sq_v.item_id v_item_id
		,sq_v.item v_item
		,sq_v.xx_item_description v_item_description
		,sq_v.quantity v_quantity
		,sq_v.uom_name v_uom_name
		,sq_v.xx_quantity_dispositioned v_quantity_dispositioned
		,sq_v.xx_defective_component v_defective_component
		,sq_v.xx_serial_number_component v_serial_number_component
		,sq_v.xx_part_number_disposition v_part_number_disposition
		,sq_v.xx_verify_nc_location v_verify_nc_location
		,sq_v.root_cause v_root_cause
		,sq_v.xx_responsibility_general v_responsibility_general
		,sq_v.xx_comments_long v_comments_long
		,sq_v.xx_nonconformance_class v_nonconformance_class
		,sq_v.xx_disposition v_disposition
		,sq_v.xx_item_shown_to v_item_shown_to
		,sq_v.xx_buy_item_under_warranty v_buy_item_under_warranty
		,sq_v.xx_failure_location_general v_failure_location_general
		,sq_v.xx_failure_location_detail v_failure_location_detail
		,sq_v.xx_organization_code v_organization_code
		,sq_v.xx_collection_plan_name v_collection_plan_name
		,sq_v.xx_database_name v_database_name
		,pcrr2.parent_plan_id d_parent_plan_id
		,pcrr2.parent_occurrence d_parent_occurrence
		,pcrr2.child_plan_id d_child_plan_id
		,pcrr2.child_occurrence d_child_occurrence
		,sq_d.disposition_row d_disposition_row
		,sq_d.disposition_row_count d_disposition_row_count
		,sq_d.plan_id d_plan_id
		,sq_d.plan_name d_plan_name
		,sq_d.organization_id d_organization_id
		,sq_d.organization_name d_organization_name
		,sq_d.collection_id d_collection_id
		,sq_d.occurrence d_occurrence
		,sq_d.last_update_date d_last_update_date
		,sq_d.last_updated_by_id d_last_updated_by_id
		,sq_d.last_updated_by d_last_updated_by
		,sq_d.creation_date d_creation_date
		,sq_d.created_by_id d_created_by_id
		,sq_d.created_by d_created_by
		,sq_d.last_update_login d_last_update_login
		--,sq_d.transaction_number d_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
		,sq_d.xx_disposition_number d_disposition_number
		,sq_d.xx_inspector_name d_inspector_name
		,sq_d.xx_event_date d_event_date
		,sq_d.xx_nonconformance_no_reference d_nonconformance_no_reference
		,sq_d.xx_rcv_inspection_no_reference d_rcv_inspection_no_reference
		,sq_d.xx_verify_nc_no_reference d_verify_nc_no_reference
		,sq_d.xx_wip_inspection_no_reference d_wip_inspection_no_reference
		,sq_d.xx_part_number_disposition d_part_number_disposition
		,sq_d.item_id d_item_id
		,sq_d.item d_item
		,sq_d.xx_item_description d_item_description
		,sq_d.xx_disposition d_disposition
		,sq_d.uom_name d_uom_name
		,sq_d.xx_quantity_dispositioned d_quantity_dispositioned
		,sq_d.xx_comments_long d_comments_long
		,sq_d.xx_responsibility_general d_responsibility_general
		,sq_d.xx_nonconformance_class d_nonconformance_class
		,sq_d.xx_repair_rework_location d_repair_rework_location
		,sq_d.vendor_id d_vendor_id
		,sq_d.supplier d_supplier
		,sq_d.supplier_site d_supplier_site
		,sq_d.po_header_id d_po_header_id
		,sq_d.po_number d_po_number
		,sq_d.po_line_number d_po_line_number
		,sq_d.xx_return_to_vendor_org d_return_to_vendor_org
		,sq_d.xx_rma_number_supplier d_rma_number_supplier
		,sq_d.xx_buyer_email_address d_buyer_email_address
		,sq_d.xx_supplier_email_address d_supplier_email_address
		,sq_d.xx_organization_code d_organization_code
		,sq_d.xx_collection_plan_name d_collection_plan_name
		,sq_d.xx_database_name d_database_name
	FROM sq_n
	LEFT JOIN sq_pcrr pcrr1 ON (
			sq_n.plan_id = pcrr1.parent_plan_id
			AND sq_n.occurrence = pcrr1.parent_occurrence
			)
	LEFT JOIN sq_v ON (
			pcrr1.child_plan_id = sq_v.plan_id
			AND pcrr1.child_occurrence = sq_v.occurrence
			)
	LEFT JOIN sq_pcrr pcrr2 ON (
			sq_v.plan_id = pcrr2.parent_plan_id
			AND sq_v.occurrence = pcrr2.parent_occurrence
			)
	LEFT JOIN sq_d ON (
			pcrr2.child_plan_id = sq_d.plan_id
			AND pcrr2.child_occurrence = sq_d.occurrence
			)
	)
        /* Return rows into custom object. */
        SELECT XXQA_NC_RPT_REC_TYPE(
            n_nonconformance_row
            ,n_plan_id
            ,n_plan_name
            ,n_organization_id
            ,n_organization_name
            ,n_collection_id
            ,n_occurrence
            ,n_last_update_date
            ,n_last_updated_by_id
            ,n_last_updated_by
            ,n_creation_date
            ,n_created_by_id
            ,n_created_by
            ,n_last_update_login
            --,n_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
            ,n_nonconformance_number
            ,n_inspector_name
            ,n_event_date
            ,n_wip_entity_id
            ,n_job
            ,n_item_id
            ,n_item
            ,n_item_description
            ,n_quantity
            ,n_uom_name
            ,n_serial_number
            ,n_failure_location_general
            ,n_failure_location_detail
            ,n_nonconformance_symptom
            ,n_comments_long
            ,n_rcv_inspection_no_reference
            ,n_wip_inspection_no_reference
            ,n_vendor_id
            ,n_supplier
            ,n_supplier_site
            ,n_po_header_id
            ,n_po_number
            ,n_po_line_number
            ,n_nonconformance_status
            ,n_organization_code
            ,n_collection_plan_name
            ,n_database_name
            ,v_parent_plan_id
            ,v_parent_occurrence
            ,v_child_plan_id
            ,v_child_occurrence
            ,v_verify_nc_row
            ,v_verify_nc_row_count
            ,v_plan_id
            ,v_plan_name
            ,v_organization_id
            ,v_organization_name
            ,v_collection_id
            ,v_occurrence
            ,v_last_update_date
            ,v_last_updated_by_id
            ,v_last_updated_by
            ,v_creation_date
            ,v_created_by_id
            ,v_created_by
            ,v_last_update_login
            --,v_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
            ,v_verify_nc_number
            ,v_inspector_name
            ,v_event_date
            ,v_nonconformance_no_reference
            ,v_rcv_inspection_no_reference
            ,v_wip_inspection_no_reference
            ,v_item_id
            ,v_item
            ,v_item_description
            ,v_quantity
            ,v_uom_name
            ,v_quantity_dispositioned
            ,v_defective_component
            ,v_serial_number_component
            ,v_part_number_disposition
            ,v_verify_nc_location
            ,v_root_cause
            ,v_responsibility_general
            ,v_comments_long
            ,v_nonconformance_class
            ,v_disposition
            ,v_item_shown_to
            ,v_buy_item_under_warranty
            ,v_failure_location_general
            ,v_failure_location_detail
            ,v_organization_code
            ,v_collection_plan_name
            ,v_database_name
            ,d_parent_plan_id
            ,d_parent_occurrence
            ,d_child_plan_id
            ,d_child_occurrence
            ,d_disposition_row
            ,d_disposition_row_count
            ,d_plan_id
            ,d_plan_name
            ,d_organization_id
            ,d_organization_name
            ,d_collection_id
            ,d_occurrence
            ,d_last_update_date
            ,d_last_updated_by_id
            ,d_last_updated_by
            ,d_creation_date
            ,d_created_by_id
            ,d_created_by
            ,d_last_update_login
            --,d_transaction_number  --transaction_number column does not exist in collection plan result views for Oracle 12.1.3 (plan was originally developed for Oracle 12.2.4)
            ,d_disposition_number
            ,d_inspector_name
            ,d_event_date
            ,d_nonconformance_no_reference
            ,d_rcv_inspection_no_reference
            ,d_verify_nc_no_reference
            ,d_wip_inspection_no_reference
            ,d_part_number_disposition
            ,d_item_id
            ,d_item
            ,d_item_description
            ,d_disposition
            ,d_uom_name
            ,d_quantity_dispositioned
            ,d_comments_long
            ,d_responsibility_general
            ,d_nonconformance_class
            ,d_repair_rework_location
            ,d_vendor_id
            ,d_supplier
            ,d_supplier_site
            ,d_po_header_id
            ,d_po_number
            ,d_po_line_number
            ,d_return_to_vendor_org
            ,d_rma_number_supplier
            ,d_buyer_email_address
            ,d_supplier_email_address
            ,d_organization_code
            ,d_collection_plan_name
            ,d_database_name
        ) FROM sq_nid
        WHERE 1=1 ]'
        || l_where_clause_seq_1
        || l_where_clause_seq_2
        || l_where_clause_seq_3
        || l_where_clause_org_id
        || ' ORDER BY sq_nid.n_nonconformance_number, sq_nid.v_verify_nc_number, sq_nid.d_disposition_number'
;

      /* Write the SQL statement to the log file so that it can be debugged should issues arise. */
      IF c_debug_level = 10 THEN dbms_output.put_line(l_dynamic_sql);
          write_message('SQL Statement in variable "l_dynamic_sql":' );
          write_message(l_dynamic_sql );
      END IF;

      /* Execute the dynamic SQL statement. */
      EXECUTE IMMEDIATE l_dynamic_sql BULK COLLECT INTO l_result_temp;

      IF c_debug_level = 10 THEN
        write_message('Rows returned: ' || l_result_temp.COUNT);

        write_message('Request ID: ' || fnd_global.conc_request_id);
        write_message(c_output_footer);

      END IF;

      RETURN l_result_temp;

      EXCEPTION
        WHEN OTHERS THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
              write_message('Unhandled exception: ' || SQLERRM );
            END IF;
          ELSE
            write_message(SQLERRM);
          END IF;

          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling.***
    END f_report_data;

    -----------------------------------------------------------------------
    --  name:               f_report_parameter_lov
    --  create by:          xxxxxxxx
    --  Revision:           1.0
    --  creation date:      xxxxxxx
    --  Purpose :           CHG0040770 - Quality Nonconformance Report
    ----------------------------------------------------------------------------------
    --  ver   date          name            desc
    --  1.0   xxxxxx        xxxxx           S3 Initial Build
    --  1.1   12-June-2017  Lingaraj(TCS)   CHG0040770  - Quality Nonconformance Report
    -----------------------------------------------------------------------------------
   FUNCTION f_report_parameter_lov (p_plan_type_code IN VARCHAR2, p_sequence_number IN VARCHAR2, p_organization_id IN NUMBER)
                RETURN APPS.XXQA_NCR_SEQ_LOV_TAB_TYPE
   IS
    --* Description:
    --*    This function facilitates the construction of a dynamic list of values as a user is
    --*    entering parameters to run the Quality Nonconformance Report.  For a given org,
    --*    all Nonconformacne Numbers would appear in the NC# paramaater LOV.  Once the NC# is chosen, the
    --*    LOV for the Verify Nonconformance Number is restricted to just those
    --*    associated with the parent NC#.  Once the VNC# is selected, only those
    --*    Dispositions associated with the VNC# will be shown in the Disposition
    --*    Number LOV.

    --* Inputs:
    --*    p_plan_type_code: Collection Plan Type
    --*    p_sequence_number: Sequence number (Nonconformance Number, Verfiy Nonconformance Number, or Disposition Number) for specific result for the collection plan type.
    --*    p_organization_id: Organization ID for which the quality nonconformance
    --*    was entered.
    --* Outputs:
    --*    XXQA_NCR_SEQ_LOV_TABLE_TYPE: contains one row for each List of Values row for the associated report parameter.
        /* Local Variables*/
        l_view_source VARCHAR2(50); --View upon which the List of Values will be based
        l_sequence_column VARCHAR2(30);  --Column in view that represents the sequence (effectively the this the unique identifier from a user's perspective).
        l_parent_sequence_column VARCHAR2(30);  --Column in view that represents the parent plan's sequence.

        l_view_name_1 VARCHAR2(50); --View name for org-specific Nonconformance collection plan
        l_view_name_2 VARCHAR2(50); --View name for org-specific Verify Nonconformance collection plan
        l_view_name_3 VARCHAR2(50); --View name for org-specific Disposition collection plan
        l_sequence_type VARCHAR2 (150);
        l_sequence_number VARCHAR2 (150);
        l_organization_id NUMBER;

        l_result_temp APPS.XXQA_NCR_SEQ_LOV_TAB_TYPE := APPS.XXQA_NCR_SEQ_LOV_TAB_TYPE();  -- Holds the result of the dynamic sql query
        l_dynamic_sql VARCHAR2(32000);  --Holds dynamic SQL statement

        /* Cursors*/
        TYPE t_ref_cursor IS REF CURSOR;-- SYS_REFCURSOR;
        cur_dynamic t_ref_cursor;

        /* Exceptions */
        PLAN_TYPE_CODE_NOT_FOUND EXCEPTION;
        PRAGMA EXCEPTION_INIT (PLAN_TYPE_CODE_NOT_FOUND, -20000);

    BEGIN
        IF c_debug_level = 10 THEN
            write_message(c_output_header);
        END IF;

        /* Prepare Parameters*/
        l_sequence_type := dbms_assert.enquote_literal(str => p_plan_type_code);--Add single quotes
        l_sequence_number := dbms_assert.enquote_literal(str => p_sequence_number);--Add single quotes
        l_organization_id := p_organization_id;

        /* Get the view names that will be used in the dynamic SQL*/
        l_view_name_1 := collection_plan_view_name(p_plan_type => c_plan_type_code_1, p_organization_id => l_organization_id); --View name for org-specific Nonconformance collection plan
        l_view_name_2 := collection_plan_view_name(p_plan_type => c_plan_type_code_2, p_organization_id => l_organization_id); --View name for org-specific Verify Nonconformance collection plan
        l_view_name_3 := collection_plan_view_name(p_plan_type => c_plan_type_code_3, p_organization_id => l_organization_id); --View name for org-specific Disposition collection plan

        IF c_debug_level = 10 THEN
            write_message('Names of views determined:' );
            write_message('Names of views determined: ' || l_view_name_1 || ', ' || l_view_name_2 || ', ' || l_view_name_3);
        END IF;

        /* Verify that each view name is valid, in part to reduce risk of SQL injection.
           Oracle will raise the exception, ORA-44002: invalid object name, if one
           of these views do not exist. */
        l_view_name_1 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_1);
        l_view_name_2 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_2);
        l_view_name_3 := DBMS_ASSERT.SQL_OBJECT_NAME(str => l_view_name_3);

        IF c_debug_level = 10 THEN
            write_message('Existence of views confirmed');
        END IF;

        IF c_debug_level = 10 THEN
            write_message('Build dynamic SQL');
        END IF;

    /* Build a dynamic SQL Statement.  Note the use of the alternative quoting
       mechanism (Q') using "[" as the quote_delimiter.  This is to make the
       use of single quotes in the variable clearer. Note that bind variables
       are not, and cannot, be used because the view/table names will be
       different across orgs. (Bind variables can't be used to specify table or
       view names.) */

    /* Determine the view that should be the source of the LOV. */
    CASE p_plan_type_code
    WHEN c_plan_type_code_1 THEN
        l_view_source := l_view_name_1;
        l_sequence_column:= c_sequence_column_1;
        l_parent_sequence_column := c_parent_sequence_column_1;
    WHEN c_plan_type_code_2 THEN
            l_view_source := l_view_name_2;
            l_sequence_column:= c_sequence_column_2;
            l_parent_sequence_column := c_parent_sequence_column_2;
    WHEN c_plan_type_code_3 THEN
            l_view_source := l_view_name_3;
            l_sequence_column:= c_sequence_column_3;
            l_parent_sequence_column := c_parent_sequence_column_3;
    /* Raise and exception if the Plan Type is not found*/
    ELSE
        RAISE PLAN_TYPE_CODE_NOT_FOUND;
    END CASE;

    /* Build dynamic SQL statement to produce a List of Values for a report parameter. */
    l_dynamic_sql := 'SELECT XXQA_NCR_SEQ_LOV_REC_TYPE(' ||
                '''' || p_plan_type_code || '''' ||
                ',' || l_parent_sequence_column ||
                ',' || l_sequence_column ||
                ',' || '''' || 'add description for this field' || '''' ||
                ', last_updated_by_id' ||
                ', last_updated_by' ||
                ', last_update_date' ||
                ', created_by_id' ||
                ', created_by' ||
                ', creation_date' ||
                ', organization_id' ||
                ', occurrence' ||
                ', xx_database_name' ||
                ') FROM ' || l_view_source;

      /* Write the SQL statement to the log file so that it can be debugged should issues arise. */
      IF c_debug_level = 10 THEN dbms_output.put_line(l_dynamic_sql);
          write_message('SQL Statement in variable "l_dynamic_sql":' );
          write_message(l_dynamic_sql);
      END IF;

      /* Execute the dynamic SQL statement. */
      EXECUTE IMMEDIATE l_dynamic_sql BULK COLLECT INTO l_result_temp;

      IF c_debug_level = 10 THEN
        write_message('Rows returned: ' || l_result_temp.COUNT);

        write_message('Request ID: ' || fnd_global.conc_request_id);

        write_message(c_output_footer);
      END IF;

      RETURN l_result_temp;

      EXCEPTION
        WHEN PLAN_TYPE_CODE_NOT_FOUND THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
                 write_message('ERROR: The collection plan type, ' || p_plan_type_code || ', is not a valid plan type on which to base the list of values.');
            END IF;
          ELSE
            write_message('ERROR: The collection plan type, ' || p_plan_type_code || ', is not a valid plan type upon which to base the list of values.');
          END IF;
          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling.***

        WHEN OTHERS THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
                 write_message('Unhandled exception: ' || SQLERRM );
            END IF;
          ELSE
            write_message(SQLERRM);
          END IF;

          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling per SSYS standards.***
   END f_report_parameter_lov;

    -----------------------------------------------------------------------
    --  Name:               print_nc_report
    --  Created By:         Hubert, Eric
    --  Revision:           1.0
    --  Creation Date:      31-Jul-2017 
    --  Purpose :           This function will create a concurrent request for the 
    --  'XXQA: Quality Nonconformance Report' (XXQA_NONCONFORMANCE_RPT).  The function has 
    --  separate arguments for the Nonconformance Number, Verify Nonconformance
    --  Number, and Disposition Number.  This allows for the printing of a 
    --  specific branch in the three-level parent-child collection plan 
    --  hierarchy.  However, in practice, there will typically be only a single
    --  verification and disposition record for a given nonconformance, thus
    --  providing just the Nonconformacne Number is sufficient.  
    --  
    --  There is an argument for explicitly indicating which printer should be used,
    --  to bypass any rules within the function for determining which printer should
    --  be used.
    ----------------------------------------------------------------------------------
    --  ver   date          name            desc
    --  1.0   31-Jul-2017   Hubert, Eric    CHG0041284 - Add Tools menu item to print Quality Nonconformance Report from quality results forms
    -----------------------------------------------------------------------------------
    FUNCTION print_nc_report (
     p_organization_id IN NUMBER
     , p_sequence_1_value IN VARCHAR2 --Nonconformance Number
     , p_sequence_2_value IN VARCHAR2 --Verify Nonconformance Number
     , p_sequence_3_value IN VARCHAR2 --Disposition Number
     , p_printer_name IN VARCHAR2 --Optional printer name  (if null, it is determined with a profile option).
    ) RETURN NUMBER --Return Concurrent Request ID
    IS
    
    /* Local Variables*/
    l_sequence_1_value VARCHAR2(10) := p_sequence_1_value; --Nonconformance Number
    l_sequence_2_value VARCHAR2(10) := p_sequence_2_value; --Verify Nonconformance Number
    l_sequence_3_value VARCHAR2(10) := p_sequence_3_value; --Disposition Number
    l_organization_id NUMBER := p_organization_id;
    l_printer_name VARCHAR2(30);--Optional printer name
    l_profile_option_value_1 VARCHAR2(30);--Profile option value for QA default label printer
    l_profile_option_value_2 VARCHAR2(30);--Profile option value for default printer
    l_profile_option_value_3 VARCHAR2(30);--Profile option value for default copies
    l_copies NUMBER;

    l_layout_result BOOLEAN;
    l_print_options_result BOOLEAN;
    l_request_id NUMBER;
    
    BEGIN
        /* Determine the printer to be used. */
        l_profile_option_value_1 := fnd_profile.value('XXQA_DEFAULT_LABEL_PRINTER');
        l_profile_option_value_2 := fnd_profile.value('Printer');
        l_profile_option_value_3 := fnd_profile.value('Concurrent:Report Copies');
        
        CASE WHEN p_printer_name IS NOT NULL THEN --Use printer explicitly passed to function
            l_printer_name := p_printer_name;
        WHEN l_profile_option_value_1 IS NOT NULL THEN
            l_printer_name := l_profile_option_value_1; --Printer from profile option (XX: QA Default Label Printer)
        WHEN l_profile_option_value_2 IS NOT NULL THEN
            l_printer_name := l_profile_option_value_2; --Printer from profile option (Printer)
        ELSE
            l_printer_name := 'noprint';  --Hardcoded default printer (noprint)
        END CASE;

        /* Determine number of copies*/
        l_copies := TO_NUMBER(l_profile_option_value_3); --Printer from profile option (Printer)

         /*Assign template*/
        l_layout_result := fnd_request.add_layout (
            template_appl_name=> 'XXOBJT',
            template_code => 'XXQA_NONCONFORMANCE_RPT',
            template_language => 'en',
            template_territory=> 'US',
            output_format => 'PDF'
        );
        
        /*Printing options*/
        l_print_options_result := fnd_request.set_print_options (
            printer => l_printer_name,
            style=> 'CANADACHEQUE',--'CA Cheque Writer/Deposit Advice' 
            copies => l_copies,
            save_output=> TRUE,
            print_together=> 'N'
        );
        
        /*Submit Request*/
        l_request_id := fnd_request.submit_request (
            application=> 'XXOBJT',
            program => 'XXQA_NONCONFORMANCE_RPT',
            description=> 'XXQA: Quality Nonconformance Report',
            start_time => '',
            sub_request=> FALSE,
            argument1 => l_organization_id,
            argument2 => l_sequence_1_value,
            argument3 => l_sequence_2_value,
            argument4 => l_sequence_3_value,
            argument5 => 'Y',--Print Verify NC Result
            argument6 => 'No',--Print Header Footer
            argument7 => 'Medium'
        );
        
        COMMIT;
        
        /*Exceptions*/
        IF ( l_request_id <> 0)
        THEN
             dbms_output.put_line('Concurrent request succeeded: ' || l_request_id);
        ELSE
             dbms_output.put_line('Concurrent Request failed to submit: ' || l_request_id);
             dbms_output.put_line('Request Not Submitted due to "' || fnd_message.get || '".');
        END IF;       

        RETURN l_request_id;
      
        EXCEPTION
        WHEN OTHERS THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
              write_message('Unhandled exception: ' || SQLERRM );
            END IF;
          ELSE
            write_message(SQLERRM);
          END IF;

          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling.***
    END print_nc_report;
    
    -----------------------------------------------------------------------
    --  Name:               p_plan_type
    --  Created By:         Hubert, Eric
    --  Revision:           1.0
    --  Creation Date:      31-Jul-2017 
    --  Purpose :           This procedure will return the Plan Type or a given 
    --  collection plan, via the plan ID.
    ----------------------------------------------------------------------------------
    --  ver   date          name            desc
    --  1.0   31-Jul-2017   Hubert, Eric    CHG0041284 - Add Tools menu item to print Quality Nonconformance Report from quality results forms
    -----------------------------------------------------------------------------------
    FUNCTION plan_type (p_plan_id IN NUMBER)
    RETURN VARCHAR2
    IS
    
        /* Local variables*/
        l_plan_type_code VARCHAR2(30);
        
        /* Exceptions */
        PLAN_TYPE_CODE_NOT_FOUND EXCEPTION;
        PRAGMA EXCEPTION_INIT (PLAN_TYPE_CODE_NOT_FOUND, -20000);
        
    BEGIN
        /* Get the plan type for the collection plan*/
        SELECT plan_type_code
        INTO l_plan_type_code
        FROM qa_plans
        WHERE plan_id = p_plan_id;
        
        dbms_output.put_line('Plan Type Code: ' || l_plan_type_code);
        
        IF l_plan_type_code IS NULL THEN
            RAISE PLAN_TYPE_CODE_NOT_FOUND;
        END IF;
        
        /* Return Plan Type Code*/
        RETURN l_plan_type_code;
        
        EXCEPTION
        WHEN PLAN_TYPE_CODE_NOT_FOUND THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
                 write_message('ERROR: The collection plan type ID, ' || p_plan_id || ', is not a valid plan type ID.');
            END IF;
          ELSE
            write_message('ERROR: The collection plan type ID, ' || p_plan_id || ', is not a valid plan type ID.');
          END IF;
          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling.***

        WHEN OTHERS THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
                 write_message('Unhandled exception: ' || SQLERRM );
            END IF;
          ELSE
            write_message(SQLERRM);
          END IF;

          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling per SSYS standards.***
    END plan_type;

    -----------------------------------------------------------------------
    --  Name:               print_ncr_from_occurrence
    --  Created By:         Hubert, Eric
    --  Revision:           1.0
    --  Creation Date:      31-Jul-2017 
    --  Purpose :           This is a wrapper function for print_nc_report.  It 
    --  simplifies the creation of the concurrent request for the report by only
    --  requiring the collection result occurrence, which is a unique ID number
    --  within the qa_results table.  From this occurrence, the required arguments
    --  can be determined to make a call of print_nc_report.
    ----------------------------------------------------------------------------------
    --  ver   date          name            desc
    --  1.0   31-Jul-2017   Hubert, Eric    CHG0041284 - Add Tools menu item to print Quality Nonconformance Report from quality results forms
    -----------------------------------------------------------------------------------
    FUNCTION print_ncr_from_occurrence (
    p_occurrence IN NUMBER
    ) RETURN NUMBER --Return Concurrent Request ID
    IS
      
        /* Local Variables*/
        l_plan_id NUMBER;
        l_plan_type_code VARCHAR2(30);
        l_sequence_1_value VARCHAR2(10) := NULL; --Nonconformance Number
        l_sequence_2_value VARCHAR2(10) := NULL; --Verify Nonconformance Number
        l_sequence_3_value VARCHAR2(10) := NULL; --Disposition Number
        l_organization_id NUMBER := NULL;
        l_printer_name VARCHAR2(30) := NULL; --Optional printer name
        l_request_id NUMBER;
    BEGIN
        /* Get the Plan ID and sequence fields of interest from the result occurrence.
        Note that the ordinal number in the variable names do not match with
        the named columns in qa_results.  When the collection elements for
        Nonconformance Number, Verify Nonconformance Number, and Disposition
        Number were created, they were explicitly associated with the
        named sequence columns indicated in the Select statement below. */
        SELECT 
            plan_id
            ,organization_id
            , sequence5 --XX_NONCONFORMANCE_NUMBER (use sequence5 in PROD)
            , sequence6 --XX_VERIFY_NC_NUMBER (use sequence6 in PROD)
            , sequence7 --XX_DISPOSITION_NUMBER (use sequence7 in PROD)
        INTO 
            l_plan_id
            , l_organization_id
            , l_sequence_1_value
            , l_sequence_2_value
            , l_sequence_3_value
        FROM qa_results
        WHERE occurrence = p_occurrence;
        
        /* Get Plan Type*/
        l_plan_type_code := plan_type(l_plan_id);
    
        /* From the Plan Type, determine some arguments for the next function call.
        Depending upon the current collection plan (in Oracle forms) provide
        the corresponding sequence number.  We make two of the sequence 
        variables null */
        CASE l_plan_type_code
        WHEN xxqa_nc_rpt_pkg.c_plan_type_code_1 THEN
            l_sequence_2_value := NULL;
            l_sequence_3_value := NULL;
        WHEN xxqa_nc_rpt_pkg.c_plan_type_code_2 THEN
            l_sequence_1_value := NULL;
            l_sequence_3_value := NULL;
        WHEN xxqa_nc_rpt_pkg.c_plan_type_code_3 THEN
            l_sequence_1_value := NULL;
            l_sequence_2_value := NULL;
        END CASE;

        /* Check that not all sequence variables are NULL, to prevent the 
        report from running wide open. */
        IF NOT (l_sequence_1_value IS NULL 
                AND l_sequence_2_value IS NULL
                AND l_sequence_3_value IS NULL
                ) THEN
 
            /* Create the concurrent request*/
            l_request_id := print_nc_report(
                p_organization_id => l_organization_id
                ,p_sequence_1_value => l_sequence_1_value
                ,p_sequence_2_value => l_sequence_2_value
                ,p_sequence_3_value => l_sequence_3_value
                ,p_printer_name => l_printer_name
            );
        ELSE
            dbms_output.put_line('All sequence variables are null.');
        END IF;

        RETURN l_request_id;
        
        EXCEPTION
        WHEN OTHERS THEN
          /* If function was called in the context of a concurrent program,
          write the error to the log file.  Otherwise write to dbms_output. */
          IF fnd_global.conc_request_id <> -1 THEN
            IF c_debug_level = 10 THEN
                 write_message('Unhandled exception: ' || SQLERRM );
            END IF;
          ELSE
            write_message(SQLERRM);
          END IF;

          /* Return*/
          RETURN NULL;--***Just did this as place holder for more targeted exception handling per SSYS standards.***
    END print_ncr_from_occurrence;

 

   --*****************************************************************************
   --*  PRIVATE FUNCTIONS
   --*****************************************************************************
   -----------------------------------------------------------------------
  --  name:               xxqa_nc_rpt_pkg
  --  create by:          xxxxxxxx
  --  Revision:           1.0
  --  creation date:      xxxxxxx
  --  Purpose :           CHG0040770 - Quality Nonconformance Report
  ----------------------------------------------------------------------------------
  --  ver   date          name            desc
  --  1.0   xxxxxx        xxxxx           S3 Initial Build
  --  1.1   12-June-2017  Lingaraj(TCS)   CHG0040770  - Quality Nonconformance Report
  -----------------------------------------------------------------------------------
   FUNCTION collection_plan_view_name (p_plan_type IN VARCHAR2, p_organization_id IN NUMBER) RETURN VARCHAR2
   /* This function returns the results view name for a plan type within a specific org.
      In the event that more than one plan for the type is found within an org, an exception is raised.*/
   IS
        l_view_name VARCHAR2(30) := NULL;
   BEGIN
        SELECT subquery.view_name INTO l_view_name FROM
        (SELECT plan_id
            ,organization_id
            ,NAME
            ,plan_type_code
            ,view_name
            ,effective_from
            ,effective_to
        FROM apps.qa_plans
        WHERE organization_id = p_organization_id--89
            /* Expect 'XX_NONCONFORMANCE', 'XX_VERIFY_NONCONFORMANCE', 'XX_DISPOSITION' */
            AND plan_type_code = p_plan_type
            /* Include only active collection plans*/
            AND TRUNC(SYSDATE) BETWEEN NVL(effective_from, TRUNC(SYSDATE))
                AND NVL(effective_to, TRUNC(SYSDATE))) subquery;

     RETURN l_view_name;

    /* Exception handling */
    EXCEPTION
    WHEN TOO_MANY_ROWS THEN
        RETURN '';
    WHEN NO_DATA_FOUND THEN
        RETURN '';
    WHEN OTHERS THEN
        RETURN '';
   END collection_plan_view_name;
END xxqa_nc_rpt_pkg;
/
